module keyboard

(

 clk,  //50MHZ

 rst_n,

 hang,   //检测行

 lie,   //列

 key_value,  //按键值
 
 word,
 hang_pose//按键按下标志

);

input clk,rst_n; 
input [3:0] hang;
output [3:0] key_value;
output  [3:0] lie;
output [3:0] hang_pose;
output [31:0] word;
reg [3:0] lie;
reg [3:0] key_value;

reg [2:0] state;  //按键按下状态
reg key_flag;   //按键按下标志
reg clk_500khz;  //500KHZ时钟
reg [3:0] lie_reg;  //列数值寄存器
reg [3:0] hang_reg;  //行时钟寄存器
reg [31:0] word;


reg [5:0] count;//时钟分频计数字
/*****************时钟分频500Khz********************8*/
always @(posedge clk or negedge rst_n)

   if(!rst_n) 
    begin clk_500khz<=0; count<=0; end

   else

    begin

      if(count>=50) begin clk_500khz<=~clk_500khz;count<=0;end

      else count<=count+1'b1;

    end
/******************结束***************888*/////



/*******************************按键按下检**************************************/

reg [3:0] key_rst;

always @(posedge clk or negedge rst_n)

        if(!rst_n)
                key_rst=4'b1111;
        else
                key_rst=hang;
   
	
reg [3:0] key_rst_r;

always @(posedge clk or negedge rst_n)

        if(!rst_n)
                key_rst_r=4'b1111;
        else
                key_rst_r=key_rst;
                
//××按键按下Kye_an值一采集按键的下降沿

wire [3:0] key_an=key_rst_r & (~key_rst);



//cnt 延时计数子延时大约50ms
reg [19:0] cnt;

always@(posedge clk or negedge rst_n)

			if(!rst_n)
					cnt=20'd0;
			else if(key_an)//检测到下降沿cnt计数子至零
					cnt=20'd0;
			else    
					cnt=cnt+1;

					
//延时后把按键的状态附给low_sw
reg [3:0] low_sw;

always@(posedge clk or negedge rst_n)

			if(!rst_n)
					low_sw=4'b1111;
			else if(cnt==20'hfffff)
					low_sw=hang;
reg [3:0] low_sw_r;

always@(posedge clk or negedge rst_n)

			if(!rst_n)
					low_sw_r=4'b1111;
			else
					low_sw_r=low_sw;
					
					
//延时后检测到按键按下时hang_pose 拉高一个时钟周期
wire [3:0] hang_pose=low_sw_r & (~low_sw); 
			

/**************************按键数值检测**********************************/
 always @(posedge clk_500khz or negedge rst_n)

   if(!rst_n) 
   begin 
	   lie<=4'b0000;
	   state<=0;
   end

   else 

    begin 

     case (state)

      0: 

         begin

			 lie[3:0]<=4'b0000;

			 key_flag<=1'b0;

			 if(hang[3:0]!=4'b1111) //(hang[3:0]!=4'b1111)表示有按键按下扫描第一行
			 begin 
			 state<=1;
			 lie[3:0]<=4'b1110;
			 end 

			 else state<=0;

         end 

      1:  

         begin

          if(hang[3:0]!=4'b1111) begin state<=5;end   //判断是第一行,ֻ�����ж�Ӧ���ʱ�������Ժ���(hang[3:0]!=4'b1111)��������

          else  begin state<=2;lie[3:0]<=4'b1101;end  //扫描第二行

         end 

      2:

         begin    

         if(hang[3:0]!=4'b1111) begin state<=5;end    //判断扫描第二行,ֻ�����ж�Ӧ���ʱ�������Ժ���(hang[3:0]!=4'b1111)��������

         else  begin state<=3;lie[3:0]<=4'b1011;end  //扫描第三行

         end

      3:

         begin    

         if(hang[3:0]!=4'b1111) begin state<=5;end   //判断是否是第三行,ֻ�����ж�Ӧ���ʱ�������Ժ���(hang[3:0]!=4'b1111)��������

         else  begin state<=4;lie[3:0]<=4'b0111;end  //判断扫描第4行

         end

      4:
         begin    

         if(hang[3:0]!=4'b1111) begin state<=5;end  //判断是否是第4行,ֻ�����ж�Ӧ���ʱ�������Ժ���(hang[3:0]!=4'b1111)��������

         else  state<=0;

         end

      5:

         begin  

          if(hang[3:0]!=4'b1111) begin

									key_flag<=1'b1;  //按键按下标识之一

									lie_reg<=lie;  //列支给寄存器

									state<=5;

									hang_reg<=hang;  //行数值给寄存器


                                  end             

          else begin
                state<=0;
                key_flag<=1'b0; 
               end 
         end    

     endcase 

    end           

  /**********************************键盘处理部分**************************/
/*************************�������̵�����ת��Ϊ��ֵ***************************/
 always @(posedge clk_500khz  or negedge rst_n)
   if(!rst_n) 
   begin
   key_value <=0;
   end
   else
     begin

        if(key_flag == 1'b1) 

                begin

                     case ({hang_reg,lie_reg})

                      8'b1110_1110:begin key_value=7;end

                      8'b1110_1101:begin key_value=8;end

                      8'b1110_1011:begin key_value=9;end

                      8'b1110_0111:begin key_value=10;end

                      

                      8'b1101_1110:begin key_value=4;end

                      8'b1101_1101:begin key_value=5;end

                      8'b1101_1011:begin key_value=6;end

                      8'b1101_0111:begin key_value=11;end

 

                      8'b1011_1110:begin key_value=1;end

                      8'b1011_1101:begin key_value=2;end

                      8'b1011_1011:begin key_value=3;end

                      8'b1011_0111:begin key_value=12;end

 

                      8'b0111_1110:begin key_value=15;end

                      8'b0111_1101:begin key_value=0;end

                      8'b0111_1011:begin key_value=14;end

                      8'b0111_0111:begin key_value=13;end     

                     endcase 
                     					
              end  
              

   end    
 
reg [31:0] word_r;
always @ (posedge clk or negedge rst_n)

	if(!rst_n)
		begin 
			word <= 32'd0;
			word_r <= 32'd0;
		end 
	else if(hang_pose!=4'b0000 )
		begin 
			if(key_value==13)
				word <= word_r;
			else if( key_value==14)
				begin 
					word <= 32'd0;
					word_r <= 32'd0;
				end 
			else
				word_r <= 10*word_r + key_value ;
		end 
 

endmodule
